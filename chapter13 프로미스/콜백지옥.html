<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <script>
        // 자바스크립트는 동기적으로 작동된다. 즉 코드블록이 이전 블록 이후에 실행된다.

        // const data = fetch('your-api-url-goes-here');
        // console.log('Finished');
        // console.log(data);

        // fetch를 사용하여 어떤 URL에서 데이터를 가져온다는 것으로 가정해보자.
        // 동기 코드의 경우, fetch 작업이 실제로 완료된 후에 다음 행이 호출될거라 예상한다.
        // 하지만 실제로는 fetch가 호출된 직후 바로 다음 행에 있는 두 console.log()도 실행되므로, 
        // 마지막 console.log(data)는  undefined를 출력한다.
        // 이러한 현상이 발생하는 이유는 fetch가 비동기적으로 수행되기 때문이다.
        // 즉, 해당 행에서 fetch가 완료될 때까지 코드 실행을 중지하는게 아니라 계속해서 다음 행을 실행한다.
        // 이 문제를 해결하기 위해 콜백 또는 프로미스를 사용하면 fetch가 무언가를 반환하는 시점까지 기다릴 수 있다.


        // 비동기 코드를 동기식으로 작동하는 것처럼 하기 위해 콜백으로 여러 코드블록을 차례로 연결해 작성할 때 발생하는 상황을 콜백지옥이라고 부르기도 한다.

        // const makePizza = (ingredients, callback) => {
        //     mixIngredients(ingredients, function(mixedIngredients)) {
        //         bakePizza(mixedIngredients, function(bakedPizza)) {
        //             console.log('finished!');
        //         }
        //     }
        // };

        // 콜백지옥을 보여주는 예제. 피자를 준비하는 각 단계마다 서버에 요청을 보내야 하고 서버가 응답할때 까지 기다렸다가 다음 단계를 수행해야 하는 비동기적인 상황이다. 이렇게 하면 시각적으로 위에서 아래로 코드가 실행되는 것처럼 보이게 작성할 수는 있지만, 과도한 함수 중첩을 유발하고 있다. 
        // 이를 개선 하기 위해 프로미스를 사용한다.


    </script>
</body>
</html>